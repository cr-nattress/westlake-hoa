# Story 8.8: Enhanced AI Context Builder

## User Story

**As a** resident using the AI assistant
**I want** the AI to have access to full document content
**So that** it can provide accurate, detailed answers with proper citations

## Description

Create an AI context builder that dynamically selects relevant document content based on the user's query. Replace the hardcoded `SAMPLE_DOCUMENT_CONTEXT` with actual document content, prioritized by topic relevance.

## Acceptance Criteria

- [ ] Context builder function receives user query and returns relevant documents
- [ ] Uses topic index to identify relevant documents
- [ ] Falls back to all current documents if no topic match
- [ ] Chunks large documents to fit context window
- [ ] Returns document metadata (title, type, status, sections)
- [ ] Prioritizes current documents over superseded
- [ ] Maximum context size configurable (default ~100k chars)

## Technical Details

### File Location
`src/lib/ai/context-builder.ts`

### Type Definitions

```typescript
export interface DocumentContext {
  title: string;
  type: string;
  status: string;
  content: string;
  sections?: string[];
  publishedAt?: string;
}

export interface AIContextResult {
  documents: DocumentContext[];
  relevantTopics: Array<{
    question: string;
    quickAnswer: string;
  }>;
  totalChars: number;
}
```

### Implementation

```typescript
import { getAllDocuments, type Document } from '@/lib/data/documents';
import { findTopicsByKeyword, TOPIC_INDEX } from '@/lib/data/topic-index';

const MAX_CONTEXT_CHARS = 100000; // ~25k tokens
const MAX_DOC_CHARS = 30000; // Per document limit

export interface DocumentContext {
  title: string;
  type: string;
  status: string;
  content: string;
  sections?: string[];
  publishedAt?: string;
}

export interface AIContextResult {
  documents: DocumentContext[];
  relevantTopics: Array<{
    question: string;
    quickAnswer: string;
  }>;
  totalChars: number;
}

/**
 * Build AI context based on user query
 * Prioritizes documents matching topic keywords
 */
export function buildAIContext(query: string): AIContextResult {
  const allDocs = getAllDocuments();
  const queryLower = query.toLowerCase();

  // Find matching topics
  const relevantTopics = findTopicsByKeyword(query);

  // Get document slugs from topics
  const topicDocSlugs = new Set<string>();
  for (const topic of relevantTopics) {
    topicDocSlugs.add(topic.primaryDocument);
    topic.relatedDocuments.forEach((slug) => topicDocSlugs.add(slug));
  }

  // Prioritize documents
  let prioritizedDocs: Document[];

  if (topicDocSlugs.size > 0) {
    // Use topic-matched documents first
    const topicDocs = allDocs.filter((d) => topicDocSlugs.has(d.slug));
    const otherCurrentDocs = allDocs.filter(
      (d) => !topicDocSlugs.has(d.slug) && d.status === 'current'
    );
    prioritizedDocs = [...topicDocs, ...otherCurrentDocs];
  } else {
    // Fall back to current documents, prioritize by type
    const typeOrder = ['policy', 'rule', 'bylaw', 'declaration', 'insurance'];
    prioritizedDocs = allDocs
      .filter((d) => d.status === 'current')
      .sort((a, b) => {
        const aIdx = typeOrder.indexOf(a.type);
        const bIdx = typeOrder.indexOf(b.type);
        return aIdx - bIdx;
      });
  }

  // Build context within size limit
  const documents: DocumentContext[] = [];
  let totalChars = 0;

  for (const doc of prioritizedDocs) {
    if (!doc.content) continue;

    let content = doc.content;

    // Truncate if necessary
    if (content.length > MAX_DOC_CHARS) {
      // Try to find relevant section
      const relevantSection = extractRelevantSection(content, queryLower);
      content = relevantSection || content.slice(0, MAX_DOC_CHARS) + '\n[...]';
    }

    // Check if we have room
    if (totalChars + content.length > MAX_CONTEXT_CHARS) {
      // Try smaller chunk
      const remaining = MAX_CONTEXT_CHARS - totalChars;
      if (remaining > 5000) {
        content = content.slice(0, remaining) + '\n[...]';
      } else {
        break; // No more room
      }
    }

    documents.push({
      title: doc.title,
      type: doc.type,
      status: doc.status,
      content,
      publishedAt: doc.published_at || undefined,
    });

    totalChars += content.length;
  }

  return {
    documents,
    relevantTopics: relevantTopics.slice(0, 3).map((t) => ({
      question: t.question,
      quickAnswer: t.quickAnswer,
    })),
    totalChars,
  };
}

/**
 * Extract section of document most relevant to query
 */
function extractRelevantSection(content: string, query: string): string | null {
  const sections = content.split(/^##\s+/m);

  // Score each section by keyword matches
  const queryWords = query.split(/\s+/).filter((w) => w.length > 3);

  let bestSection = '';
  let bestScore = 0;

  for (const section of sections) {
    const sectionLower = section.toLowerCase();
    let score = 0;

    for (const word of queryWords) {
      if (sectionLower.includes(word)) {
        score += (sectionLower.match(new RegExp(word, 'gi')) || []).length;
      }
    }

    if (score > bestScore) {
      bestScore = score;
      bestSection = section;
    }
  }

  if (bestScore > 0 && bestSection.length > 500) {
    return '## ' + bestSection.slice(0, MAX_DOC_CHARS);
  }

  return null;
}

/**
 * Get context for a specific document (for document-specific chat)
 */
export function getDocumentContext(slug: string): DocumentContext | null {
  const allDocs = getAllDocuments();
  const doc = allDocs.find((d) => d.slug === slug);

  if (!doc || !doc.content) return null;

  return {
    title: doc.title,
    type: doc.type,
    status: doc.status,
    content: doc.content.slice(0, MAX_DOC_CHARS),
    publishedAt: doc.published_at || undefined,
  };
}
```

### Update Ask Client

```typescript
// src/app/ask/ask-client.tsx
import { buildAIContext } from '@/lib/ai/context-builder';

// Replace SAMPLE_DOCUMENT_CONTEXT with dynamic context
// Pass to AIChat component for each message

export function AskClient() {
  // Build initial context (can be refined per message in API)
  const initialContext = buildAIContext('');

  return (
    <AIChat
      documentContext={initialContext.documents}
      // ...
    />
  );
}
```

### Update API Route

```typescript
// src/app/api/chat/route.ts
import { buildAIContext } from '@/lib/ai/context-builder';

export async function POST(req: Request) {
  const { messages, documentContext } = await req.json();

  // Get latest user message
  const lastUserMessage = messages.filter((m: any) => m.role === 'user').pop();

  // Build dynamic context based on query
  const context = lastUserMessage
    ? buildAIContext(lastUserMessage.content)
    : { documents: documentContext || [], relevantTopics: [] };

  // Use context.documents in system prompt
  // ...
}
```

## Story Points: 5

## Priority: Critical

## Dependencies
- Story 8.2 (Populate Document Content)
- Story 8.4 (Topic Index)

## Definition of Done
- [ ] buildAIContext function implemented
- [ ] Topic-based document prioritization works
- [ ] Document chunking respects size limits
- [ ] Section extraction finds relevant content
- [ ] Ask client uses dynamic context
- [ ] API route uses dynamic context
- [ ] No hardcoded SAMPLE_DOCUMENT_CONTEXT
- [ ] Total context size stays under limit
