# Story 8.10: Document Search Enhancement

## User Story

**As a** resident searching for information
**I want** search to look through full document content
**So that** I can find information even if I don't know the exact document title

## Description

Enhance the document search functionality to search within document content, not just titles and summaries. Add result highlighting and section-level matches.

## Acceptance Criteria

- [ ] Search queries document content (full text)
- [ ] Results show where match was found (section/context)
- [ ] Match snippets displayed with highlighting
- [ ] Relevance ranking (title match > content match)
- [ ] Search results show which section matched
- [ ] Performance acceptable (<500ms for search)
- [ ] No breaking changes to existing search

## Technical Details

### Files to Modify
- `src/lib/data/documents.ts` - Add content search
- `src/app/documents/page.tsx` - Display enhanced results

### Enhanced Search Function

```typescript
// src/lib/data/documents.ts

export interface SearchResult extends Document {
  matchType: 'title' | 'summary' | 'content';
  matchContext?: string; // Snippet around match
  matchSection?: string; // Section heading if found
  relevanceScore: number;
}

export async function searchDocuments(query: string): Promise<SearchResult[]> {
  if (!query || query.length < 2) {
    return getAllDocuments().map((d) => ({
      ...d,
      matchType: 'title' as const,
      relevanceScore: 0,
    }));
  }

  const queryLower = query.toLowerCase();
  const queryWords = queryLower.split(/\s+/).filter((w) => w.length > 2);
  const results: SearchResult[] = [];

  for (const doc of getAllDocuments()) {
    let matchType: 'title' | 'summary' | 'content' = 'content';
    let relevanceScore = 0;
    let matchContext: string | undefined;
    let matchSection: string | undefined;

    // Check title (highest priority)
    if (doc.title.toLowerCase().includes(queryLower)) {
      matchType = 'title';
      relevanceScore += 100;
    }

    // Check summary
    if (doc.summary?.toLowerCase().includes(queryLower)) {
      if (matchType !== 'title') matchType = 'summary';
      relevanceScore += 50;
    }

    // Check content
    if (doc.content) {
      const contentLower = doc.content.toLowerCase();

      // Exact phrase match
      if (contentLower.includes(queryLower)) {
        relevanceScore += 30;
        matchContext = extractMatchContext(doc.content, queryLower);
        matchSection = findMatchSection(doc.content, queryLower);
      }

      // Individual word matches
      for (const word of queryWords) {
        const matches = (contentLower.match(new RegExp(word, 'g')) || []).length;
        relevanceScore += matches * 2;
      }
    }

    // Only include if there's some match
    if (relevanceScore > 0) {
      results.push({
        ...doc,
        matchType,
        matchContext,
        matchSection,
        relevanceScore,
      });
    }
  }

  // Sort by relevance
  return results.sort((a, b) => b.relevanceScore - a.relevanceScore);
}

function extractMatchContext(content: string, query: string): string {
  const index = content.toLowerCase().indexOf(query.toLowerCase());
  if (index === -1) return '';

  const start = Math.max(0, index - 100);
  const end = Math.min(content.length, index + query.length + 100);

  let snippet = content.slice(start, end);

  // Clean up snippet
  if (start > 0) snippet = '...' + snippet;
  if (end < content.length) snippet = snippet + '...';

  return snippet;
}

function findMatchSection(content: string, query: string): string | undefined {
  const lines = content.split('\n');
  const queryLower = query.toLowerCase();

  let currentSection = '';

  for (const line of lines) {
    // Track section headings
    if (line.startsWith('## ')) {
      currentSection = line.replace('## ', '').trim();
    } else if (line.startsWith('### ')) {
      currentSection = line.replace('### ', '').trim();
    }

    // Check if query is in this line
    if (line.toLowerCase().includes(queryLower) && currentSection) {
      return currentSection;
    }
  }

  return undefined;
}
```

### Enhanced Search UI

```tsx
// src/app/documents/page.tsx

import { searchDocuments, type SearchResult } from '@/lib/data/documents';

// In the component
const results = await searchDocuments(searchQuery);

// Render result with context
<Card key={doc.id}>
  <CardHeader>
    <div className="flex items-center gap-2">
      <Badge>{doc.type}</Badge>
      {doc.matchSection && (
        <Badge variant="outline" className="text-xs">
          Found in: {doc.matchSection}
        </Badge>
      )}
    </div>
    <CardTitle>{doc.title}</CardTitle>
  </CardHeader>
  <CardContent>
    {doc.matchContext ? (
      <p className="text-sm text-muted-foreground">
        <HighlightedText text={doc.matchContext} query={searchQuery} />
      </p>
    ) : (
      <p className="text-sm text-muted-foreground">{doc.summary}</p>
    )}
  </CardContent>
</Card>

// Highlight component
function HighlightedText({ text, query }: { text: string; query: string }) {
  if (!query) return <>{text}</>;

  const parts = text.split(new RegExp(`(${query})`, 'gi'));

  return (
    <>
      {parts.map((part, i) =>
        part.toLowerCase() === query.toLowerCase() ? (
          <mark key={i} className="bg-yellow-200 dark:bg-yellow-800 px-0.5 rounded">
            {part}
          </mark>
        ) : (
          <span key={i}>{part}</span>
        )
      )}
    </>
  );
}
```

### Performance Considerations

```typescript
// For large document sets, consider:

// 1. Debounce search input
const [debouncedQuery] = useDebounce(query, 300);

// 2. Limit content search length
const searchableContent = doc.content?.slice(0, 50000); // First 50k chars

// 3. Cache search results
const searchCache = new Map<string, SearchResult[]>();

export async function searchDocumentsWithCache(query: string) {
  const cacheKey = query.toLowerCase().trim();

  if (searchCache.has(cacheKey)) {
    return searchCache.get(cacheKey)!;
  }

  const results = await searchDocuments(query);
  searchCache.set(cacheKey, results);

  // Limit cache size
  if (searchCache.size > 100) {
    const firstKey = searchCache.keys().next().value;
    searchCache.delete(firstKey);
  }

  return results;
}
```

## Story Points: 5

## Priority: Medium

## Dependencies
- Story 8.2 (Populate Document Content)

## Definition of Done
- [ ] Content search implemented
- [ ] Match context extracted correctly
- [ ] Section identification works
- [ ] Relevance ranking produces good results
- [ ] Highlighting displays matches
- [ ] Search performance < 500ms
- [ ] No regressions in existing search
- [ ] Mobile responsive results
