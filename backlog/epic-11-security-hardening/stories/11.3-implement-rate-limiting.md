# Story 11.3: Implement API Rate Limiting

## Story
**As a** system administrator
**I want to** implement rate limiting on API endpoints
**So that** the API is protected from abuse and DoS attacks

## Priority: CRITICAL
## Points: 5

## Background

The `/api/chat` endpoint currently has no rate limiting, making it vulnerable to:
- Denial of Service (DoS) attacks
- API cost abuse (Anthropic API calls are expensive)
- Resource exhaustion
- Credential stuffing attempts

## Acceptance Criteria

- [ ] Rate limiting implemented on `/api/chat` endpoint
- [ ] Configurable limits (requests per minute/hour)
- [ ] Appropriate HTTP 429 response with retry headers
- [ ] Rate limit by IP address
- [ ] Logging of rate limit violations
- [ ] Configuration via environment variables
- [ ] Works in both development and production

## Technical Details

### Upstash Rate Limiting (Recommended for Netlify)

```bash
npm install @upstash/ratelimit @upstash/redis
```

```typescript
// src/lib/rate-limit.ts
import { Ratelimit } from "@upstash/ratelimit";
import { Redis } from "@upstash/redis";

// Create rate limiter
export const ratelimit = new Ratelimit({
  redis: Redis.fromEnv(),
  limiter: Ratelimit.slidingWindow(10, "1 m"), // 10 requests per minute
  analytics: true,
  prefix: "westlake-hoa",
});

export async function checkRateLimit(identifier: string) {
  return await ratelimit.limit(identifier);
}
```

```typescript
// src/app/api/chat/route.ts
import { checkRateLimit } from "@/lib/rate-limit";

export async function POST(req: Request) {
  // Get client IP
  const ip = req.headers.get("x-forwarded-for")?.split(",")[0] ||
             req.headers.get("x-real-ip") ||
             "unknown";

  // Check rate limit
  const { success, limit, reset, remaining } = await checkRateLimit(ip);

  if (!success) {
    return new Response(
      JSON.stringify({
        error: "Rate limit exceeded. Please try again later.",
        retryAfter: Math.ceil((reset - Date.now()) / 1000)
      }),
      {
        status: 429,
        headers: {
          "Content-Type": "application/json",
          "X-RateLimit-Limit": limit.toString(),
          "X-RateLimit-Remaining": remaining.toString(),
          "X-RateLimit-Reset": reset.toString(),
          "Retry-After": Math.ceil((reset - Date.now()) / 1000).toString(),
        },
      }
    );
  }

  // Continue with normal request handling...
}
```

### Option B: In-Memory Rate Limiting (Development/Simple)

```typescript
// src/lib/rate-limit-memory.ts
const requests = new Map<string, { count: number; resetTime: number }>();

const WINDOW_MS = 60 * 1000; // 1 minute
const MAX_REQUESTS = 10;

export function checkRateLimitMemory(ip: string): {
  success: boolean;
  remaining: number;
  resetTime: number;
} {
  const now = Date.now();
  const record = requests.get(ip);

  if (!record || now > record.resetTime) {
    requests.set(ip, { count: 1, resetTime: now + WINDOW_MS });
    return { success: true, remaining: MAX_REQUESTS - 1, resetTime: now + WINDOW_MS };
  }

  if (record.count >= MAX_REQUESTS) {
    return { success: false, remaining: 0, resetTime: record.resetTime };
  }

  record.count++;
  return { success: true, remaining: MAX_REQUESTS - record.count, resetTime: record.resetTime };
}

// Cleanup old entries periodically
setInterval(() => {
  const now = Date.now();
  for (const [ip, record] of requests.entries()) {
    if (now > record.resetTime) {
      requests.delete(ip);
    }
  }
}, 60 * 1000);
```

### Environment Variables

Add these to Netlify Dashboard → Site Settings → Environment Variables:

```env
UPSTASH_REDIS_REST_URL=https://xxx.upstash.io
UPSTASH_REDIS_REST_TOKEN=xxx

# Optional rate limit configuration
RATE_LIMIT_REQUESTS=10
RATE_LIMIT_WINDOW=60  # seconds
```

For local development, add to `.env.local`.

### Rate Limit Configuration

| Environment | Requests | Window | Notes |
|-------------|----------|--------|-------|
| Development | 100 | 1 min | Generous for testing |
| Production | 10 | 1 min | Conservative default |
| Production (auth'd) | 30 | 1 min | Higher for authenticated users |

## Verification

```bash
# Test rate limiting
for i in {1..15}; do
  curl -X POST http://localhost:3021/api/chat \
    -H "Content-Type: application/json" \
    -d '{"messages":[{"role":"user","content":"test"}]}' \
    -w "\nStatus: %{http_code}\n"
  sleep 1
done

# After ~10 requests, should see 429 responses
```

## Dependencies
- `@upstash/ratelimit` (new)
- `@upstash/redis` (new)
- Upstash account (free tier available)

## Risks
- **False positives:** Users behind same IP (corporate/mobile) may share limit
- **Configuration:** Too aggressive limits frustrate users
- **Redis dependency:** Service outage could block all requests

## Mitigations
- Start with generous limits, tighten based on monitoring
- Implement fallback for Redis failures
- Consider user-agent and other factors for identification

## Notes
- Monitor rate limit hits in production
- Consider adding rate limit info to response headers always
- Future: Implement per-user rate limits with authentication
